---
title: "CITS4009 - Project 1"
author: "Tong Lan (24056082)"
date: "`r Sys.Date()`"
output: 
  html_document: 
    code_folding: hide
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
knitr::opts_chunk$set(warning=FALSE)
```

[Video link for introducing the project's Shiny apps]()

# Introduction

*The Premier League (officially known as The Football Association Premier League Limited)* [[1]][ref1] is the highest level of professional football in the English football league system. There are twenty clubs that compete against each other, with each team playing 38 matches, resulting in a total of 380 matches every season. *The Fantasy Premier League (FPL)* is the official fantasy football game of the English Premier League. It is the largest fantasy football game, with over 11.5 million players in 2023. [[2]][ref2] The game was created by ISM (International Sports Multimedia) and is owned and operated by the Premier League. [[3]][ref3]

The dataset used in this project is obtained from [*kaggle.com*](https://www.kaggle.com/), collected by *PAOLO MAZZA*. [[4]][ref4] It is a basic dataset containing the aggregated fantasy premier league data taken from *the official website Fantasy Premier League* [[5]][ref5]. In Fantasy Premier League, players create a fictional team composed of real-life football players and earn points based on their performance statistics or perceived on-field contributions. [[6]][ref6]

This project explores the 2022-23 season FPL data to identify connections and relationships between players' total scoring points, their positions, and values. It focuses especially on the top-scoring players to investigate what makes them perform well in the 2022-23 season. By analyzing and utilizing data from this project, FPL managers can improve their game strategy.

# Loading Data

Load necessary libraries for the project.

```{r library, message=FALSE}
library(tidyverse)
library(shiny)
library(htmltools)
library(fmsb)
library(RColorBrewer)
library(hrbrthemes)
library(viridis)
library(ggrepel)
library(grid)
library(gridExtra)
```

Load the dataset from a CSV file for the project.

```{r data_file, message=FALSE}
path <- "./FPL_Dataset_2022-2023.csv"
fpl_raw_data <- read.csv(path)
```

# Overview Data

To begin, we need to review the input dataset. We can do this by using the `glimpse()` function to get a general overview of the raw data, followed by using the `str()` function to examine the dataset structure. Next, we can use the `summary()` function to get a summary of the dataset. Finally, we can use the `head()` function to take a look at the first six lines of the dataset.

```{r glimpse, results='hide'}
glimpse(fpl_raw_data)
str(fpl_raw_data)
```

The `glimpse()` function and `str()` function show that the dataset has 778 rows and 75 columns and contains various data types including integer, character, double, etc. The dataset also has missing values(NA) that need to be handled.

```{r summary, results='hide'}
summary(fpl_raw_data)
```

The `summary()` function indicates that each row in the dataset represents a player, resulting in a total of 778 players for the 2022-23 season. The point total for each player ranges from 0 to 272, with an average of 40.78. The cost for each player ranges from 37 to 131, with a median of 45. According to the rule from the official FPL website [[5]][ref5], a playerâ€™s value should be between 3.0 and 14.0, and the total budget for 15 selected players is 100. We can note that the cost values are 10 times larger for easier storage in the database. The cost values might be a useful statistic to explore further.

```{r head, results='hide'}
head(fpl_raw_data)
```

Using the `head()` function, we can view the default first 6 rows, which contain various details such as the number of goals, assists, and other statistics for each player.

# Initial Transform

Before starting our exploratory data analysis, we should perform an initial transformation to make the dataset more suitable for further use. As discussed earlier, player costs range from 3.0 to 14.0, which can separate them into three different value levels: **Low**, **Middle**, and **Premium**.

To explore the most important data in FPL, which is players' total points, we should first examine the players' key performance data. Extract these data from the raw dataset and rename them for ease of exploratory data analysis. After this step, let's take a look at the transformed data for its first 5 rows.

```{r transform_1, echo=TRUE}
# get level function
get_cost_level <- function(cost_bin) {
  level <- levels(cut_interval((fpl_raw_data$now_cost) / 10, 3))
  case_when(
    cost_bin == level[1] ~ "Low",
    cost_bin == level[2] ~ "Middle",
    cost_bin == level[3] ~ "Premium",
    .default = NA
  )
}

# transform data
fpl_data <- fpl_raw_data[c(
  "web_name",
  "team",
  "position",
  "total_points",
  "points_per_game",
  "now_cost",
  "minutes",
  "goals_scored",
  "expected_goals",
  "expected_goals_per_90",
  "assists",
  "expected_assists",
  "expected_assists_per_90",
  "goals_conceded",
  "expected_goals_conceded",
  "expected_goals_conceded_per_90",
  "saves",
  "saves_per_90",
  "clean_sheets",
  "clean_sheets_per_90"
)] %>%
  rename(all_of(
    c(
      Player = "web_name",
      Club = "team",
      Position = "position",
      Points = "total_points",
      Points90 = "points_per_game",
      Cost = "now_cost",
      Minutes = "minutes",
      Goals = "goals_scored",
      xG = "expected_goals",
      xG90 = "expected_goals_per_90",
      Assists = "assists",
      xA = "expected_assists",
      xA90 = "expected_assists_per_90",
      GC = "goals_conceded",
      xGc = "expected_goals_conceded",
      xGc90 = "expected_goals_conceded_per_90",
      Saves = "saves",
      Saves90 = "saves_per_90",
      CS = "clean_sheets",
      CS90 = "clean_sheets_per_90"
    )
  )) %>%
  # cost is 10 times larger because it is easier to store a integer in the database
  # now we can return it to the actual value by diving 10
  mutate(Cost = Cost / 10) %>%
  # separate the player into three group by their values
  mutate(Cost_bin = cut_interval(Cost, 3), .after = Cost) %>%
  # category player level by their values
  mutate(Level = get_cost_level(Cost_bin), .after = Cost_bin)

# remove data: fpl_raw_data to save memory
rm(fpl_raw_data)

# show the table(first six rows)
knitr::kable(fpl_data[1:5,], caption =  "First 5 rows of fpl_data")
```

```{r transform_2, include=FALSE}
Positions <-  c("FWD", "MID", "DEF", "GKP")
Levels <- unique(fpl_data$Level)
Clubs <- unique(fpl_data$Club)
Costs <- seq(from = 4, to = 13.5, by = 0.5)
```

# Exploring Points Distribution

## Points Distribution of Players

The first thing we want to explore is the distribution of points for players, as points are what FPL is all about. To gain a clear insight, we can analyse players who played regularly, which means they played at least 1000 minutes in a single season.

```{r desity}
fpl_data %>%
  filter(Minutes >= 1000) %>%
  ggplot(aes(x = Points)) +
  geom_density(fill = "#69b3a2",
               color = "#e9ecef",
               alpha = 0.6) +
  xlim(0, 300) +
  ggtitle("Points distribution of players") +
  theme_ipsum() +
  theme(plot.title = element_text(size = 20))
```

The density plot reveals that players' total points are typically centered around 80-100 points, although the top player can score over 200 points in a season. According to FPL rules [[7]][ref7], players from different positions have different methods for calculating their scoring points. Therefore, we can group players by position and examine their point distributions.

```{r multiple_desity}
fpl_data %>%
  filter(Minutes >= 1000) %>%
  ggplot(aes(x = Points, group = Position, fill = Position)) +
  geom_density(adjust = 1.5, alpha = 0.6) +
  xlim(0, 300) +
  ggtitle("Points distribution of players") +
  labs(subtitle = "Grouped by Player Position") +
  theme_ipsum() +
  theme(plot.title = element_text(size = 20),
        plot.subtitle = element_text(size = 14))
```

Based on the multiple density plot, it is evident that the distribution of defenders is the most concentrated, resulting in them scoring fewer points than other positions. While goalkeepers have a wider range of points, even the best goalkeeper cannot score very high points. The distribution of midfielders and forwards is similar, but the top forwards have the potential to score the most points in a season.

## Top 50 Players

Once we have a general understanding of the total points earned by players, our next step is to examine the top 50 players.

```{r barplot, fig.height=12}
fpl_data %>%
  arrange(-Points) %>%
  head(50) %>%
  mutate(Player = paste0(Player, " - ", Cost, "m", sep = " ")) %>%
  mutate(Player = fct_reorder(Player, Points)) %>%
  ggplot(aes(x = Player, y = Points, fill = Position)) +
  geom_bar(stat = "identity",
           alpha = 0.8,
           width = 0.8) +
  geom_label(
    aes(y = Points, label = Points),
    position = position_stack(vjust = 1),
    size = 2,
    show.legend = F
  ) +
  ylim(0, 300) +
  coord_flip() +
  scale_color_brewer(palette = 3) +
  ggtitle("Top 50 Players with the Highest Points") +
  xlab("") +
  theme(plot.title = element_text(hjust = .5)) +
  theme_ipsum()
```

The horizontal barplot confirms our observations that the top 6 players, all of whom scored more than 200 points, are midfielders and forwards. Additionally, players who cost more in the same position tend to score better points. This suggests a correlation between points, positions, and values that should be explored in the next step.

# Correlation between Points and Positions and Values



## Correlation between Points and Positons

```{r shiny_multiple_distribution}
multiple_distribution_ui <-  fluidPage(
   tags$head(
    tags$style(
      HTML("
           .title{
          text-align: center;
           font-size: 24px;
           font-weight: bold;
           color: #3c8dbc;
           padding: 20px;
           }
           ")
    )
  ),
  div(class = "title", "Total points distribution across different levels"),
  
  sidebarLayout(
    sidebarPanel(
      selectInput(
        "type",
        "Chart Type",
        choices = list(
          "boxplot" = 1,
          "violin" = 2,
          "donut" = 3
        ),
        selected = 1
      ),
      
      checkboxGroupInput(
        "positions",
        "Position",
        choices = list(
          "FWD" = "FWD",
          "MID" = "MID",
          "DEF" = "DEF",
          "GKP" = "GKP"
        ),
        selected = Positions
      ),
      
      checkboxGroupInput(
        "levels",
        "Levels",
        choices = list(
          "Premium" = "Premium",
          "Middle" = "Middle",
          "Low" = "Low"
        ),
        selected = Levels
      ),
      
    ),
    
    mainPanel(plotOutput("plot"))
    
  )
)

multiple_distribution_server <-  function(input, output) {
  output$plot <- renderPlot({
    # all selected position
    positions <- input$positions
    # all selected levels
    levels <- input$levels
    # filter
    plot_data <-
      fpl_data %>% filter(Position %in% positions, Level %in% levels)
    # type
    if (nrow(plot_data) == 0) {
      return (NULL)
    }
    plot_type = input$type
    if (plot_type == 1) {
      blox(plot_data)
    } else if (plot_type == 2) {
      violin(plot_data)
    } else if (plot_type == 3) {
      donut(plot_data)
    }
  })
  
  # plot_functions
  blox <- function(plot_data) {
    plot_data %>%
      ggplot(aes(x = Level, y = Points, fill = Position)) +
      geom_boxplot() +
      stat_summary(
        fun = mean,
        geom = "point",
        shape = 20,
        size = 10,
        color = "#ec7014",
        fill = "#ec7014"
      ) +
      scale_fill_viridis(discrete = TRUE, alpha = 0.6) +
      geom_jitter(color = "black",
                  size = 0.4,
                  alpha = 0.9) +
      ylim(0, 300) +
      xlab("Level") +
      theme_ipsum()
  }
  
  violin <- function(plot_data) {
    plot_data %>%
      ggplot(aes(x = Level, y = Points, fill = Position)) +
      geom_violin(alpha = .6) +
      xlab("Level") +
      theme_ipsum()
  }
  
  donut <- function(plot_data) {
    # the beauty of pipeline %>%
    aggregate(plot_data$Points,
              by = list(Position = plot_data$Position),
              FUN = sum) %>%
      mutate(
        percentage = x / sum(x),
        ymax = cumsum(percentage),
        ymin = c(0, head(ymax, n = -1)),
        labelPosition = (ymax + ymin) / 2,
        label = paste(Position,
                      "\n",
                      round(percentage, 2) * 100,
                      "%",
                      sep = "")
      ) %>%
      ggplot(aes(
        ymax = ymax,
        ymin = ymin,
        xmax = 4,
        xmin = 3,
        fill = Position
      )) +
      geom_rect() +
      coord_polar(theta = "y") +
      geom_label(x = 3.5,
                 aes(y = labelPosition, label = label),
                 size = 5) +
      scale_fill_brewer(palette = 4) +
      scale_color_brewer(palette = 3) +
      xlim(c(2, 4)) +
      theme_void() +
      theme(legend.position = "none")
  }
  
}

shinyApp(
  ui = multiple_distribution_ui,
  server = multiple_distribution_server,
  options = list(height = '500', width = '100%')
)
```



```{r shiny_radar}
# different position compare different data in radar chart
get_radarCols <- function(Position) {
  if (Position == 'FWD' | Position == 'MID') {
    return (c(
      "Points",
      "Assists",
      "xA",
      "xA90",
      "Minutes",
      "xG90",
      "xG",
      "Goals"
    ))
  } else if (Position == 'DEF') {
    return (c(
      "Points",
      "GC",
      "xGc",
      "xGc90",
      "Minutes",
      "CS90",
      "CS",
      "Points90"
    ))
  } else{
    return (c(
      "Points",
      "GC",
      "xGc",
      "xGc90",
      "Minutes",
      "Saves90",
      "Saves",
      "Points90"
    ))
  }
}

radar_ui <- fluidPage(
  tags$head(tags$style(
    HTML(
      "
           .title{
           text-align: center;
           font-size: 24px;
           font-weight: bold;
           color: #3c8dbc;
           padding: 20px;
           }
           "
    )
  )),
  
  div(class = "title", "Compare two different players in the same position"),
  
  sidebarLayout(
    sidebarPanel(tabsetPanel(
      tabPanel(
        "Player 1",
        br(),
        # player1
        selectInput("club1",
                    "Club",
                    choices = Clubs,
                    selected = Clubs[1]),
        
        selectInput(
          "position1",
          "Position",
          choices = Positions,
          selected = Positions[1]
        ),
        
        selectInput("player1",
                    "Name",
                    choices = NULL),
        
        textInput("value1",
                  "Value",
                  value = NULL)
        
      ),
      
      tabPanel(
        "Player 2",
        br(),
        # player2
        selectInput("club2",
                    "Club",
                    choices = Clubs,
                    selected = Clubs[1]),
        
        selectInput("position2",
                    "Position",
                    choices = NULL),
        
        
        selectInput("player2",
                    "Name",
                    choices = NULL),
        
        textInput("value2",
                  "Value",
                  value = NULL),
      )
    )),
    mainPanel(plotOutput("radar"), tableOutput("table"))
  )
)

radar_server <- function(input, output, session) {
  # player 1 filter
  player1_filter <- reactive({
    fpl_data %>%
      filter(Club == input$club1, Position == input$position1) %>%
      arrange(desc(Cost))
  })
  
  observeEvent(player1_filter(), {
    choices <- unique(player1_filter()$Player)
    updateSelectInput(inputId = "player1", choices = choices)
  })
  
  # player 2 filter
  player2_filter <- reactive({
    fpl_data %>%
      filter(Club == input$club2,
             Position == input$position2,
             Player != input$player1) %>%
      arrange(desc(Cost))
  })
  
  observeEvent(player2_filter(), {
    choices <- unique(player2_filter()$Player)
    updateSelectInput(inputId = "player2", choices = choices)
  })
  
  # player 2 position depends on player 1
  observeEvent(input$position1, {
    updateSelectInput(inputId = "position2", choices = c(input$position1))
  })
  
  # player 1 value depends on player 1 name
  player1_value_filter <- reactive({
    value_player <-  fpl_data %>%
      filter(Player == input$player1)
    value_player$Cost
  })
  
  observeEvent(input$player1, {
    player1_value_text <- paste0(player1_value_filter(), "m", seq = "")
    updateTextInput(inputId = "value1", value = player1_value_text)
  })
  
  # player 2 value depends on player 2 name
  player2_value_filter <- reactive({
    value_player <-  fpl_data %>%
      filter(Player == input$player2)
    value_player$Cost
  })
  
  observeEvent(input$player2, {
    player2_value_text <- paste0(player2_value_filter(), "m", seq = "")
    updateTextInput(inputId = "value2", value = player2_value_text)
  })
  
  # radar data
   radar_data_filter <- reactive({
    # organize data
    req(input$player1)
    req(input$player2)
    radarCols <- get_radarCols(input$position1)
    fpl_data %>%
      filter(Player %in% c(input$player1, input$player2)) %>%
      select(all_of(radarCols))
  })
  
  output$radar <- renderPlot({
    radarCols <- get_radarCols(input$position1)
    plot_data <- radar_data_filter()
    plot_data <-
      rbind(c(
        max(fpl_data[radarCols[1]]),
        max(fpl_data[radarCols[2]]),
        max(fpl_data[radarCols[3]]),
        max(fpl_data[radarCols[4]]),
        max(fpl_data[radarCols[5]]),
        max(fpl_data[radarCols[6]]),
        max(fpl_data[radarCols[7]]),
        max(fpl_data[radarCols[8]])
      ),
      rep(0, 8),
      plot_data)
   
    # color vector
    colors_border = c(rgb(0.2, 0.5, 0.5, 0.9),
                      rgb(0.8, 0.2, 0.5, 0.9),
                      rgb(0.7, 0.5, 0.1, 0.9))
    
    colors_in = c(rgb(0.2, 0.5, 0.5, 0.4),
                  rgb(0.8, 0.2, 0.5, 0.4),
                  rgb(0.7, 0.5, 0.1, 0.4))
    
    # plot with default options:
    radarchart(
      plot_data,
      axistype = 1 ,
      #custom polygon
      pcol = colors_border ,
      pfcol = colors_in ,
      plwd = 4 ,
      plty = 1,
      #custom the grid
      cglcol = "grey",
      cglty = 1,
      axislabcol = "grey",
      caxislabels = seq(0, 20, 5),
      cglwd = 0.8,
      #custom labels
      vlcex = 0.8
    )
    
    # add a legend
    legend(
      x = 1.2,
      y = 1,
      legend = c(input$player1, input$player2),
      bty = "n",
      pch = 20 ,
      col = colors_in ,
      text.col = "grey",
      cex = 1.2,
      pt.cex = 3
    )
  })
  
  output$table <- renderTable({
    radar_data_filter() %>%
      mutate(Player = c(input$player1, input$player2),
             .before = Points)
  })
  
}

shinyApp(
  ui = radar_ui,
  server = radar_server,
  options = list(height = '600', width = '100%')
)
```



## Correlation between Points and Values

```{r shiny_scatter}
scatter_ui <- fluidPage(
  tags$head(tags$style(
    HTML(
      "
           .title{
           text-align: center;
           font-size: 24px;
           font-weight: bold;
           color: #3c8dbc;
           padding: 20px;
           }
           "
    )
  )),
  div(class = "title", "Compare Player Points by Level or Value"),
  
  sidebarLayout(
    sidebarPanel(
      selectInput("level",
                  "Level",
                  choices = Levels,
                  selected = Levels[2]),
      
      sliderInput(
        "value_range",
        "Value Range",
        min = 3.7,
        max = 13.1,
        value = c(6.83, 9.97),
        step = 0.1
      )
      
    ),
    mainPanel(plotOutput("scatter"))
  )
)

scatter_server <- function(input, output) {
  # change the value slider depends on level
  observeEvent(input$level, {
    new_level <- input$level
    if (new_level == Levels[1]) {
      updateSliderInput(inputId = "value_range", value = c(3.7, 6.83))
    } else if (new_level == Levels[2]) {
      updateSliderInput(inputId = "value_range", value = c(6.83, 9.97))
    } else {
      updateSliderInput(inputId = "value_range", value = c(9.97, 13.1))
    }
  })
  
  output$scatter <- renderPlot({
    plot_data <- fpl_data %>%
      filter(Points > 50) %>%
      filter(Cost > input$value_range[1], Cost <= input$value_range[2])
    
    ggplot(plot_data, aes(x = Points, y = Cost)) +
      geom_point(aes(color = Position, shape = Position),
                 size = 1.5,
                 alpha = 0.8) +
      scale_color_manual(values = c("#386cb0", "#fdb462", "#7fc97f", "red")) +
      xlim(0, 300) +
      geom_text_repel(
        aes(label = Player),
        family = "Poppins",
        size = 3,
        min.segment.length = 0,
        seed = 42,
        box.padding = 0.5,
        max.overlaps = Inf,
        nudge_x = .15,
        nudge_y = .5,
        color = "grey50"
      ) +
      labs(x = "total points",
           y = "cost(m)") +
      theme(
        # The default font when not explicitly specified
        text = element_text(
          family = "Lobster Two",
          size = 8,
          color = "black"
        ),
        
        # Customize legend text, position, and background.
        legend.text = element_text(size = 9, family = "Roboto"),
        legend.position = c(1, 0.85),
        legend.justification = c(1, 0),
        legend.background = element_blank(),
        # This one removes the background behind each key in the legend
        legend.key = element_blank(),
        legend.title = element_blank(),
        
        # Adjust axis parameters such as size and color.
        axis.text = element_text(size = 10, color = "black"),
        axis.title = element_text(size = 12),
        axis.ticks = element_blank(),
        # Axis lines are now lighter than default
        axis.line = element_line(colour = "grey50"),
        
        # Only keep y-axis major grid lines, with a grey color and dashed type.
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(color = "#b4aea9", linetype =
                                            "dashed"),
        
        # Use a light color for the background of the plot and the panel.
        panel.background = element_rect(fill = "#fbf9f4", color = "#fbf9f4"),
        plot.background = element_rect(fill = "#fbf9f4", color = "#fbf9f4")
      )
    
  })
}

shinyApp(ui = scatter_ui,
         server = scatter_server,
         options = list(height = '500', width = '100%'))
```

# high value(premium) players have a higher conver rate, are closer to the expected values

# data_transform, divide players by group, step = 1

# will club make a high xG coverted rate player to be a pk taker?

```{r transform_3, results='hide'}
# fpl_data_diff, the next column is based on the result of the last column
# use mutate one time for one column here
fpl_data <- fpl_data %>%
  mutate(xG_diff = Goals - xG, .after = xG,) %>% 
  mutate(xA_diff = Assists - xA, .after = xA) %>%
  mutate(xGc_diff = GC - xGc, .after = xGc) %>%
  mutate(Goals90 = Goals / (Minutes / 90), .before = xG90) %>%
  mutate(xG90_diff = Goals90 - xG90, .after = xG90) %>%
  mutate(Assists90 = Assists / (Minutes / 90), .before = xA90) %>%
  mutate(xA90_diff = Assists90 - xA90, .after = xA90) %>%
  mutate(GC90 = GC / (Minutes / 90), .before = xGc90) %>%
  mutate(xGc90_diff = GC90 - xGc90, .after = xGc90)

# new data table
knitr::kable(fpl_data[1:5, ], caption = "first 5 rows of fpl_data after adding diff and avg_90 data")

# count missing values
missing_values <- apply(is.na(fpl_data), 2, sum)
na_values <- which(missing_values > 0)
# if actual value and expected value are all 0, then the actual value 90 and expected value 90 will be NaN
# if min > 0, give it an average value, others it is 0
#  expected90 values NaN means the player did not play a single minute, make it NA
  attach(fpl_data)
  Goals90 <- ifelse(is.na(Goals90), 0, Goals90)
  Assists90 <- ifelse(is.na(Assists90), 0, Assists90)
  GC90 <- ifelse(is.na(fpl_data$GC90), 0, GC90)
  xG90_diff <- Goals90 - xG90
  xA90_diff <- Assists90 - xA90
  xGc90_diff <- GC90 - xGc90
  detach(fpl_data)
# look at the missing values again, it is clean
missing_values <- apply(is.na(fpl_data), 2, sum)

performance_data <- fpl_data[c(
  "Player",
  "Club",
  "Position",
  "Level",
  "Cost",
  "Points",
  "Minutes",
  "Points90",
  "Goals90",
  "xG90",
  "xG90_diff",
  "Assists90",
  "xA90",
  "xA90_diff",
  "GC90",
  "xGc90",
  "xGc90_diff",
  "CS90"
)]
```

Let take a look at the per 90 values.

```{r horizontal_violin}
# create a new data frame for plot[Cost, Value, Type], which is not a tidy data
# reshape data here, use provide_long() to create a tidy data
performance_data[c(
  "Minutes",
  "Points90",
  "Goals90",
  "Assists90",
  "GC90",
  "CS90"
)] %>%
  pivot_longer (2:6, names_to = "Per90", values_to = "Value") %>%
  ggplot(aes(x = Per90, y = Value, fill = Per90, color = Per90)) +
  geom_violin(width = 1, size = 0.2) +
  scale_fill_viridis(discrete = T) +
  scale_color_viridis(discrete = T) +
  theme_ipsum() + 
  ggtitle("Distribution of per 90 Values") + 
  xlab("") + 
  ylab("Actual Value per 90") +
  coord_flip() + 
  geom_jitter(alpha = .5, size = 1)
```

Outlier should be players play less than 90, so their per90 values are extremely high. Transfer these data into NA, because when we are trying to analyse the performance of players by using the per90 data, these players who played less than 90 mins make no sense.

```{r transform_4}
performance_data <- performance_data %>% 
  mutate_all(~ifelse(Minutes < 90, NA, .)) %>% 
  na.omit()
```

```{r shiny_gridExtra}
# type checkbox choices
type_choices <- max(performance_data$Goals)
assists_max <- max(performance_data$Assists)
gc_max <- max(performance_data$GC)

# stats type
stats_checkbox <- list(
  "Points" = "Points",
  "Minutes" = "Minutes",
  "Goals" = "Goals",
  "Assists" = "Assists",
  "Goals Concede" = "GC",
  "Clean Sheets" = "CS"
)
stats_attack <- c("Points", "Minutes", "Goals", "Assists")
stats_defence <- c("Points", "Minutes", "GC", "CS")
stats_points <- c("Points")
stats_minutes <- c("Minutes")
stats_goals <- c("Goals90", "xG90", "xG90_diff")
stats_assists <- c("Assists90", "xA90", "xA90_diff")
stats_gc <- c("GC90", "xGc90", "xGc90_diff")
stats_cs <- c("CC90")
all_stats <-
  c(stats_points, stats_goals, stats_assists, stats_gc, stats_cs)

gridExtra_ui <- fluidPage(
  tags$head(tags$style(
    HTML(
      "
           .title{
           text-align: center;
           font-size: 24px;
           font-weight: bold;
           color: #3c8dbc;
           padding: 20px;
           }
           "
    )
  )),
  
  div(class = "title", "Compare players' actual values and expected values"),
  
  sidebarLayout(
    sidebarPanel(
      selectInput(
        "position",
        "Position",
        choices = Positions,
        selected = Positions[1]
      ),
      
      selectInput("level",
                  "Level",
                  choices = Levels,
                  selected = Levels[3]),
      
      sliderInput(
        "value_range",
        "Value Range",
        min = 3.7,
        max = 13.1,
        value = c(9.97, 13.1),
        step = 0.1
      ),
      
      checkboxGroupInput("types",
                         "Show Stat",
                         choices = stats_checkbox,
                         selected = stats_attack),
      
    ),
    
    mainPanel(plotOutput("plot"))
  ),
  
  fluidRow(column(12, tableOutput("table")))
)

gridExtra_server <- function(input, output) {
  # define a function to get show stats
  get_stats_by_type <- function(type) {
    case_when(
      type == "Points" ~ stats_points,
      type == "Minutes" ~ stats_minutes,
      type == "Goals" ~ stats_goals,
      type == "Assists" ~ stats_assists,
      type == "GC" ~ stats_gc,
      type == "CS" ~ stats_gc
    )
  }
  
  # change the checkbox default depends on position
  observeEvent(input$position, {
    new_position <- input$position
    if (new_position == Positions[1] |
        new_position == Positions[2]) {
      updateCheckboxGroupInput(inputId = "types", selected = stats_attack)
    } else{
      updateCheckboxGroupInput(inputId = "types", selected = stats_defence)
    }
  })
  
  # change the value slider depends on level
  observeEvent(input$level, {
    new_level <- input$level
    if (new_level == Levels[1]) {
      updateSliderInput(inputId = "value_range", value = c(3.7, 6.83))
    } else if (new_level == Levels[2]) {
      updateSliderInput(inputId = "value_range", value = c(6.83, 9.97))
    } else {
      updateSliderInput(inputId = "value_range", value = c(9.97, 13.1))
    }
  })
  
  output$plot <- renderPlot({
    # all show types
    types <- input$types
    # get all the show stats name
    show_stats <- ""
    if (is.null(types)) {
      show_stats <- c(stats_points, stats_goals)
    } else{
      for (type in strsplit(types, ", ")) {
        show_stats <- unique(c(show_stats, get_stats_by_type(type)))
      }
    }
    show_stats <- show_stats[show_stats != ""]
    
    # plot_data
    plot_data <- performance_data %>%
      filter(Cost > input$value_range[1],
             Cost <= input$value_range[2],
             Position == input$position)
    
    player_number <- length(plot_data)
    
    # plot
    p1 = NA
    p2 = NA
    p3 = NA
    p4 = NA
    p5 = NA
    p6 = NA
    
    if (nrow(plot_data) > 0) {
      if (!is.null(types)) {
        if ("Points" %in% types) {
          p1 <- points_plot(plot_data)
        }
        if ("Minutes" %in% types) {
          p2 <- minutes_plot(plot_data)
        }
        if ("Goals" %in% types) {
          p3 <- goals_plot(plot_data)
        }
        if ("Assists" %in% types) {
          p4 <- assists_plot(plot_data)
        }
        if ("GC" %in% types) {
          p5 <- gc_plot(plot_data)
        }
        if ("CS" %in% types) {
          p6 <- cs_plot(plot_data)
        }
      }
    }
    
    # grid
    plot_list <- list(p1, p2, p3, p4, p5, p6)
    # remove plot NAs
    plot_list <-  plot_list[!is.na(plot_list)]
    if (length(plot_list) > 0) {
      # arrange
      grid.arrange(grobs = plot_list, ncol = 2, )
    }
  })
  
  # plot for points
  points_plot <- function(plot_data) {
    plot_data %>%
      select(c("Cost", "Points90")) %>%
      mutate(Value = Points90, Type = "Points90") %>%
      plot()
  }
  
  # plot for minutes
  minutes_plot <- function(plot_data) {
    plot_data %>%
      select(c("Cost", "Minutes")) %>%
      mutate(Value = Minutes, Type = "Minutes") %>%
      plot()
  }
  
  # plot for goals
  goals_plot <- function(plot_data) {
    plot_data %>%
      select(c("Cost", "Goals90", "xG90", "xG90_diff")) %>%
      pivot_longer (2:4, names_to = "Type", values_to = "Value") %>%
      plot()
  }
  
  # plot for assists
  assists_plot <- function(plot_data) {
    plot_data %>%
      select(c("Cost", "Assists90", "xA90", "xA90_diff")) %>%
      pivot_longer (2:4, names_to = "Type", values_to = "Value") %>%
      plot()
  }
  
  # plot for goals concede
  gc_plot <- function(plot_data) {
    plot_data %>%
      select(c("Cost", "GC90", "xGc90", "xGc90_diff")) %>%
      pivot_longer (2:4, names_to = "Type", values_to = "Value") %>%
      plot()
  }
  
  # plot for clean sheets
  cs_plot <- function(plot_data) {
    plot_data %>%
      select(c("Cost", "CS90")) %>%
      mutate(Value = CS90, Type = "CS90") %>%
      plot()
  }
  
  # plot line chart
  plot <- function(data) {
    data %>%
      ggplot(aes(
        x = Cost,
        y = Value,
        group = Type,
        color = Type
      )) +
      geom_line() +
      scale_color_viridis(discrete = TRUE) +
      xlab("Cost(m)") +
      ylab("") +
      theme_ipsum() +
      theme(legend.title = element_blank())
  }
  
  output$table <- renderTable({
    # all show types
    types <- input$types
    # get all the show stats name
    show_stats <- ""
    if (is.null(types)) {
      show_stats <- c(stats_points, stats_goals)
    } else{
      for (type in strsplit(types, ", ")) {
        show_stats <- unique(c(show_stats, get_stats_by_type(type)))
      }
    }
    show_stats <- show_stats[show_stats != ""]
    performance_data %>%
      filter(Cost > input$value_range[1],
             Cost <= input$value_range[2],
             Position == input$position) %>%
      arrange(desc(Cost)) %>%
      select(all_of(c("Player", "Level", "Cost", show_stats)))
    
  })
  
}

shinyApp(
  ui = gridExtra_ui,
  server = gridExtra_server,
  options = list(height = '750', width = '100%')
)
```

# Conclusion

Let return to the top 50 players, after the discussions above, we can find out that xxx. Use a heatmap to verify our observation.

```{r heatmap, fig.height=6, fig.width=8}
# select the top 30 players
plot_data <- performance_data %>%
  arrange(-Points) %>%
  head(30) %>%
  mutate(
    Position_name = paste(Position, Player, sep = " - "),
    Side_color = case_when(
      Position == Positions[1] ~ "#7fc97f",
      Position == Positions[2] ~ "#386cb0",
      Position == Positions[3] ~ "red",
      Position == Positions[4] ~ "#fdb462"
    )
  )

# create heatmap data
heatmap_data <- plot_data %>%
  select(Points:CS90) %>%
  as.matrix()

# color, green for below average, blue for above average
color_1 <-
  colorRampPalette(colors = c('#00FF87', '#33CCFF'))(6)[1:5]
color_2 <- colorRampPalette(colors = c('#33CCFF', '#5190FF'))(6)

# classify general stats, attack stats and defense stats
col_side_color <-
  case_when(
    attr(heatmap_data, which = "dimnames")[[2]] %in% c(
      "Goals90",
      "xG90",
      "xG90_diff",
      "Assists90",
      "xA90",
      "xA90_diff"
    ) ~ "#ec7014",
    attr(heatmap_data, which = "dimnames")[[2]] %in% c(
      "CS90", 
      "GC90", 
      "xGc90", 
      "xGc90_diff"
    ) ~ "#737373",
    .default = "purple"
  )

# plot
heatmap(
  heatmap_data,
  labRow = plot_data$Position_name,
  scale = "column",
  col = c(color_1, color_2),
  cexRow = 1.2,
  cexCol = 1.2,
  RowSideColors = plot_data$Side_color,
  ColSideColors = col_side_color
)

# add legends
legend(
  "topleft",
  legend = c(
    "Potion - FWD",
    "Potion - MID",
    "Potion - DEF",
    "Potion - GKP",
    "General",
    "Offensive",
    "Defensive",
    "Above average",
    "Average",
    "Below Average"
  ),
  cex = 0.6,
  pt.cex = 1,
  fill = c(
    "#7fc97f",
    "#386cb0",
    "red",
    "#fdb462",
    "purple",
    "#ec7014",
    "#737373",
    "#5190FF",
    "#33CCFF",
    "#00FF87"
  )
)
```

# Reference

1. ["English football league system"](https://en.wikipedia.org/wiki/English_football_league_system). *en.wikipedia.org.*
2. ["How Many Play FPL?"](https://allaboutfpl.com/2022/06/number-of-people-who-played-fpl-each-season-how-many-play-fpl/). *allaboutfpl.com.*
3. ["Fantasy_Premier_League"](https://en.wikipedia.org/wiki/Fantasy_Premier_League). *en.wikipedia.org.*
4. ["Fantasy Premier League Dataset 2022-2023"](https://www.kaggle.com/datasets/meraxes10/fantasy-premier-league-dataset-2022-2023). *www.kaggle.com*
5. ["Official Website Fantasy Premier League"](https://fantasy.premierleague.com/). *fantasy.premierleague.com*
6. ["Fantasy football (association)"](https://en.wikipedia.org/wiki/Fantasy_football_(association)). *en.wikipedia.org.*
7. ["Official Website Fantasy Premier League Rules"](https://fantasy.premierleague.com/help/rules). *fantasy.premierleague.com*

98. ["TheDataDigest"](https://www.youtube.com/@TheDataDigest). *www.youtube.com*
99. ["Equitable Equations"](https://www.youtube.com/@EquitableEquations). *www.youtube.com*

[ref1]: https://en.wikipedia.org/wiki/English_football_league_system
[ref2]: https://allaboutfpl.com/2022/06/number-of-people-who-played-fpl-each-season-how-many-play-fpl/
[ref3]: https://en.wikipedia.org/wiki/Fantasy_Premier_League
[ref4]: https://www.kaggle.com/datasets/meraxes10/fantasy-premier-league-dataset-2022-2023
[ref5]: https://fantasy.premierleague.com/
[ref6]: https://en.wikipedia.org/wiki/Fantasy_football_(association)
[ref7]: https://fantasy.premierleague.com/help/rules

